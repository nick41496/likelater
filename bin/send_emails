#!/usr/bin/env node

const _ = require('lodash');
const async = require('async');
const fs = require('fs');
const handlebars = require('handlebars');
const nodemailer = require('nodemailer');
const pg = require('pg');
const twitter = require('twitter');

const twitter_client = new twitter({
    consumer_key: process.env.CONSUMER_KEY,
    consumer_secret: process.env.CONSUMER_SECRET,
    bearer_token: process.env.BEARER_TOKEN
});

pg.connect(process.env.DATABASE_URL, (err, client, done) => {
    if (err) throw err;
    client.query('SELECT * from users', (err, result) => {
        done();

        if (err) throw err;

        const users = result.rows;

        async.eachSeries(users, (user, user_callback) => {
            const accounts = [];
            async.eachSeries(user.handles, (handle, handle_callback) => {
                if (!handle.active) {
                    console.log(`Skipping ${handle.handle}`);
                    return handle_callback(null);
                }
                let get_options = {
                    screen_name: handle.handle,
                    count: '200'
                };
                if (handle.latest_tweet) {
                    get_options.since_id = handle.latest_tweet;
                }

                twitter_client.get('favorites/list', get_options, (err, tweets) => {
                    if (err) return handle_callback(err);
                    link_tweets = _.filter(tweets, (tweet) => {
                        const urls = _.filter(tweet['entities']['urls'], (url) => {
                            return !/twitter\.com\/.*\/status\//g.test(url.expanded_url);
                        });
                        return urls.length > 0;
                    });
                    const tweet_htmls = [];
                    if (link_tweets.length > 0) {
                        handle.latest_tweet = link_tweets[0].id_str;
                    }
                    async.each(link_tweets, (tweet, html_callback) => {
                        twitter_client.get('statuses/oembed', {
                            url: `https://twitter.com/${tweet.user.screen_name}/status/${tweet.id_str}`,
                            hide_media: true
                        }, (err, tweet) => {
                            if (err) html_callback(err);
                            tweet_htmls.push(tweet);
                            html_callback(null);
                        });
                    }, (err) => {
                        if (err) return handle_callback(err);
                        const account = {
                            handle: handle.handle,
                            tweets: tweet_htmls
                        };
                        if (tweet_htmls.length > 0) {
                            account.new_tweets = true;
                        } else {
                            account.new_tweets = false;
                        }
                        accounts.push(account);
                        return handle_callback(null);
                    });
                });
            }, (err) => {
                if (err) return user_callback(err);
                fs.readFile('templates/email_template.html', 'utf8', (err, email_template) => {
                    const send = accounts.reduce((result, account) => {
                        return result || account.new_tweets;
                    }, false);
                    if (send) {
                        console.log(`Sending email to ${user.email}`);
                        const encrypted_email = user.email; //TODO: make this not send in plaintext
                        const template = handlebars.compile(email_template);
                        const message = template({ 
                            accounts: accounts,
                            encrypted_email: encrypted_email
                        });
                        send_email(user.email, message, (err) => {
                            if (err) return user_callback(err);
                            update_latest(user.email, user.handles, (err) => {
                                if (err) return user_callback(err);
                                return user_callback(null);
                            });
                        });
                    } else {
                        console.log(`Not sending email to ${user.email}, they're all caught up`);
                        return user_callback(null);
                    }
                });
            });
        }, (err) => {
            if (err) throw err;
        });
    });
});

function update_latest(email, handles, callback) {
    const query = 'UPDATE users SET handles = $1 WHERE email = $2;';
    pg.connect(process.env.DATABASE_URL, (err, client, done) => {
        client.query(query, [ JSON.stringify(handles), email ], (err) => {
            done();

            if (err) return callback(err);

            return callback(null);
        });
    });
}

function send_email(email, message, callback) {
    var mailOptions = {
        port: 465,
        host: "mail.privateemail.com",
        auth: {
            user: process.env.EMAIL_USER,
            pass: process.env.EMAIL_PASSWORD
        }
    };
    var transporter = nodemailer.createTransport(mailOptions);

    transporter.sendMail({
        from: 'info@likelater.io',
        to: email,
        subject: 'Daily link recap',
        html: message
    }, (error, info) => {
        if (error) return callback(error);

        return callback(null);
    });
};
