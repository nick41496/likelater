#!/usr/bin/env node

const _ = require('lodash');
const async = require('async');
const fs = require('fs');
const handlebars = require('handlebars');
const nodemailer = require('nodemailer');
const pg = require('pg');
const twitter = require('twitter');

const twitter_client = new twitter({
    consumer_key: process.env.CONSUMER_KEY,
    consumer_secret: process.env.CONSUMER_SECRET,
    bearer_token: process.env.BEARER_TOKEN
});

pg.connect(process.env.DATABASE_URL, (err, client, done) => {
    client.query('SELECT * from users WHERE active=TRUE', (err, result) => {
        done();

        if (err) {
            console.error(err);
            return;
        }

        const users = result.rows;

        async.eachSeries(users, (user, user_callback) => {
            const accounts = [];
            async.eachOfSeries(user.handles, (handle, i, handle_callback) => {
                let get_options;
                if (handle.latest_tweet) {
                    get_options = {
                        screen_name: handle.handle,
                        since_id: handle.latest_tweet,
                        count: '200'
                    }
                } else {
                    get_options = {
                        screen_name: handle.handle,
                        count: '200'
                    }
                }

                twitter_client.get('favorites/list', get_options, (err, tweets) => {
                    if (err) {
                        console.error(err);
                        return;
                    }
                    link_tweets = _.filter(tweets, (tweet) => {
                        const urls = _.filter(tweet['entities']['urls'], (url) => {
                            return !/twitter\.com\/.*\/status\//g.test(url.expanded_url);
                        });
                        return urls.length > 0;
                    });
                    const tweet_htmls = [];
                    handle.latest_tweet = link_tweets[0].id_str;
                    //users.handles[i].latest_tweet = link_tweets[0].id_str;
                    async.each(link_tweets, (tweet, html_callback) => {
                        console.log(`https://twitter.com/${tweet.user.screen_name}/status/${tweet.id_str}`);
                        twitter_client.get('statuses/oembed', {
                            url: `https://twitter.com/${tweet.user.screen_name}/status/${tweet.id_str}`,
                            hide_media: true
                        }, (err, tweet) => {
                            if (err) {
                                console.error(err);
                                html_callback(err);
                            }
                            tweet_htmls.push(tweet);
                            html_callback(null);
                        });
                    }, (err) => {
                        if (err) {
                            console.error(err);
                            throw err;
                        }
                        const account = {
                            handle: handle,
                            tweets: tweet_htmls
                        };
                        if (tweets.length > 0) {
                            account.new_tweets = true;
                        } else {
                            account.new_tweets = false;
                        }
                        accounts.push(account);
                        return handle_callback(null);
                    });
                });
            }, (err) => {
                if (err) {
                    console.error(err);
                    throw err;
                }
                fs.readFile('templates/email_template.html', 'utf8', (err, email_template) => {
                    const template = handlebars.compile(email_template);
                    const message = template({ accounts: accounts });
                    send_email(user.email, message, (err) => {
                        if (err) {
                            console.error(err);
                            throw err;
                        }
                        return user_callback();
                    });
                });
            });
        }, (err) => {
            if (err) {
                console.log(err);
                throw err;
            }
            console.log(users);
        });
    });
});

function update_latest(email, handles, callback) {
    const query = 'UPDATE users SET handles = $1 WHERE email = $2;';
    pg.connect(process.env.DATABASE_URL, (err, client, done) => {
        client.query(query, [ handles, email ], (err, result) => {
            done();

            if (err) return callback(err);

            return callback(null, result);
        });
    });
}

function send_email(email, message, callback) {
    console.log(`to: ${email}`);
    console.log(message);
    var mailOptions = {
        port: 465,
        host: "mail.privateemail.com",
        auth: {
            user: process.env.EMAIL_USER,
            pass: process.env.EMAIL_PASSWORD
        }
    };
    var transporter = nodemailer.createTransport(mailOptions);

    transporter.sendMail({
        from: 'nick@nickwhite.co',
        to: email,
        subject: 'Daily link recap',
        html: message
    }, (error, info) => {
        if (error) {
            return console.log(error);
        }
        console.log(info);
    });
};
